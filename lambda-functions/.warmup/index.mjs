
/** Generated by Serverless WarmUp Plugin **/

import { LambdaClient, InvokeCommand } from '@aws-sdk/client-lambda';

const uninstrumentedLambdaClient = new LambdaClient({
  apiVersion: '2015-03-31',
  region: 'ap-northeast-2'
});

const lambdaClient = uninstrumentedLambdaClient;

const functions = [
  {
    "name": "flood-info-backend-dev-getFloodData",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-getHanRiverData",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-getFloodDataByLocation",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-getMultiSourceData",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-getMultiSourceDataList",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-refreshFloodData",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-refreshRegionData",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-getDataStatus",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-cleanupOldData",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-getSafeRoute",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-checkProximity",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-getAlternativeRoute",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-geocodeAddress",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-reverseGeocode",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-websocketConnect",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-websocketDisconnect",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-websocketMessage",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-scheduledRefresh",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-dailyCleanup",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-healthCheck",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  },
  {
    "name": "flood-info-backend-dev-getSystemStatus",
    "config": {
      "enabled": true,
      "payload": "{\"source\":\"serverless-plugin-warmup\"}",
      "concurrency": 1
    }
  }
];

function logVerbose(str) {
  console.log(str);
}

function getConcurrency(func, envVars) {
  const functionConcurrency = envVars[`WARMUP_CONCURRENCY_${func.name.toUpperCase().replace(/-/g, '_')}`];

  if (functionConcurrency) {
    const concurrency = parseInt(functionConcurrency);
    logVerbose(`Warming up function: ${func.name} with concurrency: ${concurrency} (from function-specific environment variable)`);
    return concurrency;
  }

  if (envVars.WARMUP_CONCURRENCY) {
    const concurrency = parseInt(envVars.WARMUP_CONCURRENCY);
    logVerbose(`Warming up function: ${func.name} with concurrency: ${concurrency} (from global environment variable)`);
    return concurrency;
  }

  const concurrency = parseInt(func.config.concurrency);
  logVerbose(`Warming up function: ${func.name} with concurrency: ${concurrency}`);
  return concurrency;
}

export const warmUp = async (event, context) => {
  logVerbose('Warm Up Start');

  const invokes = await Promise.all(functions.map(async (func) => {
    const concurrency = getConcurrency(func, process.env);

    const clientContext = func.config.clientContext !== undefined
      ? func.config.clientContext
      : func.config.payload;

    const invokeCommand = new InvokeCommand({
      ClientContext: clientContext
        ? Buffer.from(`{"custom":${clientContext}}`).toString('base64')
        : undefined,
      FunctionName: func.name,
      InvocationType: 'RequestResponse',
      LogType: 'None',
      Qualifier: func.config.alias || process.env.SERVERLESS_ALIAS,
      Payload: func.config.payload
    });

    try {
      await Promise.all(Array(concurrency).fill(0).map(async () => await lambdaClient.send(invokeCommand)));
      logVerbose(`Warm Up Invoke Success: ${func.name}`);
      return true;
    } catch (e) {
      console.error(`Warm Up Invoke Error: ${func.name}`, e);
      return false;
    }
  }));

  logVerbose(`Warm Up Finished with ${invokes.filter(r => !r).length} invoke errors`);
}